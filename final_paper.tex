\documentclass[12pt, a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{libertinust1math}

\usepackage{csquotes}
\usepackage[english]{babel}
\usepackage[backend=biber, style=apa, sorting=nyt]{biblatex}
\addbibresource{final.bib}

\usepackage{graphicx}
\usepackage{subcaption}
\graphicspath{{./assets/}}

\title{The distribution of Rust contributors: An analysis of a relatively young language}
\author{Joshua Megnauth}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}
Open source software is a unique phenomenon in terms of multiple areas of study including philosophy, sociology, political science, software development, and others. Mass, open cooperation is an immensely difficult proposition. Yet "the world runs on open source" is a common refrain that refers to the uncontroversial notion that free software is everywhere (\cite{fossdatasci2020}). Linux and FreeBSD run most of our software which in turn run open source servers. Middleware libraries such as OpenSSL glue together systems. Even consoles, such as every PlayStation beyond PlayStation 2, run on open source kernels. Sony notably uses FreeBSD in their consoles (\cite{ps4freebsd}).

Free software's openness and prevalence alone makes research enticing. However, another factor is version control systems, like \textit{Git}, coupled with public sites that host projects such as \textit{GitHub} or \textit{GitLab}. GitHub and others host or mirror thousands of projects with a range of sizes. Much of the data on users, projects, and the projects they contribute to are public. The data are rich consisting of dates and times, textual data on conversations about contributions, as well as the heavily layered contributions themselves.

One of the most interesting projects on GitHub is the Rust programming language. Rust is developed in a transparent manner with RFCs posted on GitHub (\cite{rustrfcs}). The majority\footnote{At least since 2011. Older Rust development from back when the language was a side project may be available somewhere.} of Rust's development from its early days to everything from Rust's current state is visible on GitHub (\cite{rustlang}). The merits of new language features or changes are discussed fairly publicly with recorded meetings available on issues (\cite{rustteammeets}). Finally, Rust is a relatively new programming language that takes aim at a stalwart, C as well as C++, C's classy sibling. That fact is not important by default, but Rust actually has momentum while challenging C which is perhaps one of the most fascinating recent developments in software development. For example, developers on Stack Overflow, a platform used to ask programming questions, voted Rust as their favorite language for four years in a row (\cite{stackoverflowdevsurvey2020}). Mozilla has successfully ported some of Firefox's code from C++ to Rust---a process colloquially called \textit{oxidation}.

All of this is to say that the enterprising computational social scientist is able to more or less track Rust's development over at least a decade. Said scientist is able to watch contributors work on an exciting, growing language as well as work on important libraries used in the ecosystem, such as Serde. Researchers may focus on different areas depending on their interests. Open source has elements of anarchism, democracy, socialism, as well as liberalism depending on whom one asks. Thus, researchers in the humanities or the digital humanities, for example, have access to a large scale participatory program during growth. My research's route is different: complex networks. Version control systems such as Git or Subversion are perfect for network analysis since they're effectively laid out as graphs. Contributor networks function like co-posting networks as one would craft for researchers, actors, or writers.

\subsection{Research question and caveats}
Are Rust developers assortative based on whether they work on the core, middleware libraries, or projects? A relatively young language like Rust may have many people who contribute to both the core of the language as well as high profile projects. This is not the case with mature languages. The developers of well trafficked Python data science libraries such as Pandas or matplotlib don't necessarily contribute to the Python language itself. For Rust, however, I've noticed that some high profile Rust programmers also contribute back to the language. Jeremy Soller is the principal engineer of System76, a Linux laptop company. Soller is also well known within the Rust community for starting and greatly contributing to an experimental, Unix-like operating system written completely in Rust known as RedoxOS. Soller contributed back to the Rust language to fix issues\footnote{https://github.com/rust-lang/rust/search?q=jackpot51&type=commits} encountered when working on Redox (\cite{lunduke31317}). Another excellent example is BurntSushi (Andrew Gallant). BurntSushi is involved in the core development of the language but is also known for developing the world's fastest \textit{grep}---\textit{ripgrep}, programmed in Rust---which Microsoft uses in Visual Studio Code (\cite{gallant2016}).

I faced some notable limitations with my research which I'll discuss in a limitations section. Currently, I consider my research to be something of a toy project that should be repeated with more data. However, my open source code should be sufficient to repeat and extend the project.

As a nascent but growing language, studying the graph of Rust contributors is thus novel as well useful for the social sciences. Open source projects can be rather dramatic at times leading to controversial forks. Forks such as pfSense/OpnSense, OpenSSL/LibreSSL, FFmpeg/libav, Nexuiz/Xonotic, OpenOffice/LibreOffice, and many others were the result of disagreements rather than good spirited splits. However, Rust is a stable project where additions and new ideas seem to encounter less friction than some other projects. Future studies could focus on the elements that seem to help Rust avoid controversies and bad blood.

\section{Background: Rust and GitHub analysis}
\subsection{Rust}
Rust is a systems programming language that draws inspiration from OCaml, Haskell, C++, Erlang, Ruby, and others (\cite{rustlang}). Rust's guiding principal is memory safety based on fixing the unsafe qualities of languages like C. C is sometimes described as a "cowboy" language or a language full of "foot-guns." C is full of undefined behavior that the language trusts the programmer to avoid. The language is similarly reticent to complain about incorrect memory access, such as going beyond the bounds of a buffer. C offers extreme power but exacts a mental toll on programmers that must be hyper aware of the implications of their code. Even the best programmers continue to write code that is memory unsafe due to the extreme difficulty of getting it right. Use after free, buffer overflows, dereferencing null pointers, non-thread safe variables, double free, et cetera are all still common and happen by accident more than ignorance (\cite{hosfeltsafety2019}). The Chromium project notes that 70\% of their bugs are related to memory issues that Rust would solve (\cite{chromiummem70}). Rust piqued Mozilla's interest for the same reason which is why they adopted the language with gusto. Mozilla, as mentioned earlier, has rewritten sections of Firefox in Rust over time to catch unsafe behavior at compile time (cite\{hosfeltrewrite2019}).

Rust is notoriously difficult due to a mechanism known as the \textit{borrow checker}. The borrow checker is something of a static analysis tool that imposes restrictions on the access and mutability of data. With all of that said, Rust aims to be as fast or faster than C. Rust is built on explicitness and zero cost abstractions. Like C and C++, programmers don't pay for what they don't use. Rust's strong functional background means that the language precludes classes; Rust is only OOP if you squint and add qualifiers to your definition. Programming in Rust feels far more ergonomic when an idiomatic style of composition and lambda calculus is used rather than trying to build up a C++ or Java style class system. That

\section{Methods}

\section{Results}

\end{document}